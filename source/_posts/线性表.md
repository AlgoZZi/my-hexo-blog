---
title: 线性表
date: 2026-02-13 16:20:29
tags:
- 数据结构
- 算法
- 线性表
categories:
- 数据结构（C++）
description: 线性表（顺序表、链表等）的实现与核心算法，附约瑟夫环解法和递归算法等
---



1. [顺序表](#一、顺序表)
    1.1 [结构类型的描述](#1.结构类型的描述)
    1.2 [顺序表类的定义](#2.顺序表类的定义)
    1.3 [构造函数](#3.构造函数)
    1.4 [复制构造函数](#4.复制构造函数)
    1.5 [按值查找算法](#5.按值查找算法)
    1.6 [插入算法](#6.插入算法)
    1.7 [删除算法](#7.删除算法)
    1.8 [集合的并运算](#8.集合的并运算)
    1.9 [集合的交运算](#9.集合的交运算)

2. [单链表](#二、单链表)
    2.1 [单链表的建立](#1.单链表的建立)
    2.2 [用模板定义的结点类](#2.用模板定义的结点类)
    2.3 [用模板定义的单链表类](#3.用模板定义的单链表类)
    2.4 [输出链表所有结点值的算法](#4.输出链表所有结点值的算法)
    2.5 [求单链表长度的算法](#5.求单链表长度的算法)
    2.6 [定位算法](#6.定位算法)
    2.7 [搜索算法](#7.搜索算法)
    2.8 [插入算法](#8.插入算法)
    2.9 [删除算法](#9.删除算法)
    2.10 [析构函数](#10.析构函数)

3. [循环链表](#三、循环链表)
    3.1 [用模板定义的结点类](#1.用模板定义的结点类)
    3.2 [用模板定义的循环链表类](#2.用模板定义的循环链表类)
    3.3 [搜索算法](#3.搜索算法)
    3.4 [插入算法](#4.插入算法)
    3.5 [删除算法](#5.删除算法)

4. [双向循环链表](#四、双向循环链表)
    4.1 [模板定义的链表结点类](#1.模板定义的链表结点类)
    4.2 [模板定义的双向循环链表类](#2.模板定义的双向循环链表类)
    4.3 [搜索算法](#3.搜索算法)
    4.4 [插入算法](#4.插入算法)
    4.5 [删除算法](#5.删除算法)

5. [约瑟夫问题](#五、约瑟夫问题)

6. [递归成员函数](#六、递归成员函数)
    6.1 [不带表头结点输出链表元素值](#1.不带表头结点输出链表元素值)
    6.2 [带表头结点输出链表元素值](#2.带表头结点输出链表元素值)
    6.3 [单链表表长](#3.单链表表长)



# 一、顺序表

## 1.结构类型的描述

### 静态存储表示

```cpp
#define maxSize 100
//const int maxSize=100;

typedef int T;
typedef struct
{
    T data[maxSize];    //顺序表的静态存储表示
    int n;  //int last;
}SeqList;
```

<br>

### 动态存储表示

```cpp
typedef int T;
typedef struct
{
    T *data;    //顺序表的动态存储表示
    int maxSize;
    int n;  //int last;
}SeqList;
```

<br>

## 2.顺序表类的定义

```cpp
const int defaultSize=100;
template<class T>
class SeqList
{
protected:
    T *data;    //存放数组
    int maxSize;    //最大可容纳表项的项数
    int last;   //数组中最后一个元素的下标
    void reSize(int newSize);   //改变数组空间大小
    
public:
    SeqList(int sz=defaultSize);    //析构函数
    SeqList(SeqList<T> &L); //  复制构造函数
    ~SeqList()  //析构函数
    {
        delete []data;
    }
    int Size() const    //求表的最大容量
    {
        return maxSize;
    }
    int Length() const  //计算表长度
    {
        return last+1;
    }
    int Search(T &x) const; //搜索x在表中位置，函数返回表项序号
    int Locate(int i) const;    //定位第i个表项，函数返回表项序号
    bool getData(int i,T &x);   //取第i个元素
    bool Insert(int i,T &X);    //插入
    bool Remove(int i,T &x);    //删除
    
};
```

<br>

## 3.构造函数

```cpp
template<class T>
SeqList<T>::SeqList(int sz)
{
    if(sz>0)
    {
        maxSize=sz;
        last=-1;
        data=new T[maxSize];    //创建表存储数组
        if(data==0)     //动态分配失败
        {
            cerr <<"存储分配错误！" <<endl;
            exit(1);
        }
    }
}
```

<br>

## 4.复制构造函数

```cpp
template<class T>
SeqList<T>::SeqList(SeqList<T> &L)
{
    T value;
    maxSize=L.size();
    last=L.Length()-1;  
    data=new T[maxSize];    //创建存储数组
    if(data==0) //动态分配失败
    {
        cerr <<"存储分配错误!" <<endl;
        exit(1);
    }
    for(int i=1;i<=last+1;++i)  //传送各个表项
    {
        L.getData(i,value);
        data[i-1]=value;
    }
}
```

<br>

## 5.按值查找算法

```cpp
//按值查找算法
template<class T>
int SeqList<T>::Search(T &x) const
{
    //在表中顺序搜索与给定值x匹配的表项，找到则函数返回该表项是第几个元素，否则返回0
    for(int i=1;i<=last+1;++i)    //顺序搜索
    {
        if(data[i-1]==x)
        {
            return i;
        }
    }
    return 0;   //搜索失败
}
```

<br>

## 6.插入算法

```cpp
//插入算法
template<class T>
bool SeqList<T>::Insert(int i,T &x)
{
    if(last==maxSize-1) //表满
    {
        return false;
    }
    if(i<1 || i>Length()+1)
    {
        return false;   //参数i不合理
    }
    for(int j=last+1;j>=i;--j)  //依次后移
    {
        data[j]=data[j-1];
    }
    data[i-1]=x;    //插入
    last++;
    return true;    //插入成功
}
```

<br>

## 7.删除算法

```cpp
//删除算法
template<class T>
bool SeqList<T>::Remove(int i,T &x)
{
    //从表中删除第i个表项，通过应用型参数x返回被删元素。函数返回删除成功信息
    if(last==-1)
    {
        return false;   //表空
    }
    if(i<1 || i>last+1)
    {
        return false;   //参数i不合理
    }
    x=data[i-1];
    for(int j=i;j<=last;++j)    //依次前移
    {
        data[j-1]=data[j];
    }
    last--;
    return true;
}
```

<br>

## 8.集合的并运算

```cpp
//集合的 并 运算
void Union(SeqList<int> &LA,SeqList<int> &LB)
{
    int n1=LA.Length();
    int n2=LB.Length();
    int i,k,x;
    for(i=1;i<=n2;++i)
    {
        LB.getData(i,x);    //在LB中任取一元素
        k=LA.Search(x);     //在LA中搜索他
        if(k==0)    //若在LA中未找到，插入它
        {
            LA.Insert(n1+1,x);  //插入到第n个表项位置
            n1++;
        }
    }
}
```

<br>

## 9.集合的交运算

```cpp
//集合的 交 运算
void Intersection(SeqList<int> &LA,SeqList<int> &LB)
{
    int n1=LA.Length();
    int x,k,i=1;
    while(i<=n1)
    {
        LA.getData(i,x);    //在LA中取一元素
        k=LB.Search(x); //在LB中搜索它
        if(k==0)    //找不到
        {
            LA.Remove(i,x); //找不到，删除
            n1--;
        }
        else
        {
            i++;
        }
    }
}
```

<br>

<br>

# 二、单链表

## 1.单链表的建立

### 链表结点

```cpp
struct LinkNode //链表结点
{
    int data;   //T data;
    LinkNode *link;
};
```

<br>

### 头插法

```cpp
//头插法
template<class T>
List<T>::HLinkList(int n)
{
    first=0;
    for(int i=0;i<n;++i)
    {
        p=new LinkNode<T>();
        cin >>p->data;
        p->link=first;
        first=p;
    }
}
```

<br>

### 尾插法

```cpp
//尾插法
template<class T>
List<T>::RLinkList(int n)
{
    first=tail=new LinkNode<T>();
    first->link=0;
    for(int i=0;i<n;++i)
    {
        p=new LinkNode<T>;
        cin >>p->data;
        p->link=0;
        tail->link=p;
        tail=p;
    }
}
```

<br>

## 2.用模板定义的结点类

```cpp
//用模板定义的结点类
template<class T>
struct LinkNode //链表结点类的定义
{
    T data; //数据域
    LinkNode<T> *link;  //链指针域
    LinkNode()  //构造函数
    {
        link=0;
    }
    LinkNode(T item,LinkNdoe<T> *ptr=0) //构造函数，创建新的结点
    {
        data=item;
        link=ptr;
    }
    bool operator==(T X)    //重载函数，判断相等
    {
        return data.key==x; 
    }
    bool operator!=(T x)    
    {
        return data.key!=x;
    }
};
```

<br>

## 3.用模板定义的单链表类

```cpp
//用模板定义的单链表类
template<class T>
class List
{
protected:
    LinkNode<T> *first; //表头指针

public:
    List()  //构造函数
    {
        first=new LinkNode<T>;
    }
    List(T x)   //构造函数
    {
        first=new LinkNode<T>(x);
    }
    List(List<T> &L);   //复制构造函数
    ~List(){}   //析构函数
    void makeEmpty();   //将链表置为空表
    int Length() const; //计算链表的长度
    LinkNode<T> *Search(T x);   //搜索含x元素
    LinkNode<T> *Locate(int x); //定位第i个元素
    T *getData(int i);  //取出第i个元素值
    void setData(int i,T x);    //更新第i元素值
    bool Insert(int i,T x); //在第i元素后插入
    bool Remove(int i,T &x);    //删除第i个元素
    bool IsEmpty() const    //判断表空
    {
        return first->link==0 ? true : false;
    }
    LinkNode<T> *getFirst() const
    {
        return first;
    }
    void setFirst(LinkNode<T> *f)
    {
        first=f;
    }
    void sort();    //排序
    void Print();   //输出整条链表的结点值
};
```

<br>

## 4.输出链表所有结点值的算法

```cpp
//输出链表所有结点值的算法
template<class T>
void List<T>::Print()
{
    LinkNode<T> *p=first->link;
    while(p!=0)
    {
        cout <<p->data <<" ";
        p=p->link;
    }
}
```

<br><br>

## 5.求单链表长度的算法

```cpp
//求单链表长度的算法
template<class T>
int List<T>::Length() const
{
    LinkNode<T> *p=first->link;
    int count=0;    //检测指针p指示第一个结点
    while(p!=0)
    {
        count++;
        p=p->link;
    }
    return count;
}
```

<br>

## 6.定位算法

```cpp
//单链表的定位算法
template<class T>
LinkNode<T> *List<T>::Locate(int i)
{
    //函数返回第i个元素的地址
    if(i<0)
    {
        return 0;
    }
    LinkNode<T> *current=first;
    int k=0;
    while(current!=0 && k<i)
    {
        current=current->link;
        k++;
    }
    return current; //返回第i号结点地址或0
}
```

<br>

## 7.搜索算法

```cpp
//单链表的搜索算法
template<class T>
LinkNode<T> *List<T>::Search(T x)
{
    //在表中搜索含数据x的结点，搜索成功是函数返回该结点地址
    LinkNode<T> *current=first->link;
    while(current!=0 && current->data!=x)
    {
        current=current->link;
    }
    return current;
}
```

<br>

<br>

## 8.插入算法

```cpp
//插入算法
//将新元素x插入在链表中第i个结点之后
//将新元素x插入在链表中第i个结点之前，则可以插在i之后，再对换i和i+1的data值
template<class T>
bool List<T>::Insert(int i,T x)
{
    //将新元素x插入在链表中第i个结点之后
    LinkNode<T> *current=Locate(i);
    if(current==0)  //无插入位置
    {
        return false;
    }
    LinkNode<T> *newNode=new LinkNode<T>(x);
    newNode->link=current->link;
    current->link=newNode;
    return true;
}
```

<br>

## 9.删除算法

```cpp
//删除算法
template<class T>
bool List<T>::Remove(int i,T &x)
{
    LinkNode<T> *current=Locate(i-1);
    if(current==0 || current->link==0)//删除不成功
    {
        return false;
    }
    LinkNode<T> *del=current->link;
    current->link=del->link;
    x=del->data;
    delete del;
    return true;
}
```

<br>

## 10.析构函数

```cpp
//析构函数
template<class T>
List<T>::~List()//析构函数：从链头开始删
{
    LinkNode<T> *q;
    while(first!=0)
    {
        q=first;    //保存被删结点
        first=first->link;  //从链上摘下该结点
        delete q;   //删除
    }
}
```

<br>

<br>

# 三、循环链表

## 1.用模板定义的结点类

```cpp
template<class T>
struct CircLinkNode //链表结点类的定义
{
    T data; //数据域
    CircLinkNode<T> *link;  //链指针域
    CircLinkNode(CircLinkNode<T> *next=0)  //构造函数
    {
        link=next;
    }
    CircLinkNode(T d,CircLinkNode<T> *next=0) //构造函数，创建新的结点
    {
        data=d;
        link=next;
    }
    bool operator==(T X)    //重载函数，判断相等
    {
        return data.key==x.key; 
    }
    bool operator!=(T x)    
    {
        return data.key!=x.key;
    }
};
```

<br>

## 2.用模板定义的循环链表类

```cpp
//用模板定义的循环链表类
template<class T>
class CircList
{
private:
    CircLinkNode<T> *first,*last; //头指针，尾指针

public:
    CircList(const T x);  //构造函数
    CircList(CircList<T> &L);   //复制构造函数
    ~CircList(){}   //析构函数
    int Length() const; //计算链表的长度
    CircLinkNode<T> *Search(T x);   //搜索含x元素
    CircLinkNode<T> *Locate(int x); //定位第i个元素
    T *getData(int i);  //取出第i个元素值
    void setData(int i,T x);    //更新第i元素值
    bool Insert(int i,T x); //在第i元素后插入
    bool Remove(int i,T &x);    //删除第i个元素
    bool IsEmpty() const    //判断表空
    {
        return first->link==0 ? true : false;
    }
    LinkNode<T> *getFirst() const   //返回表头结点地址
    {
        return first;
    }
    void setFirst(LinkNode<T> *f)   //设置表头结点地址
    {
        first=f;
    }
    void sort();    //排序
    void Print();   //输出整条链表的结点值
};
```

<br>

<br>

## 3.搜索算法

```cpp
//搜索算法
template<class T>
CircLinkNode<T> *CircList<T>::Search(T x)
{
    //在链表中从头搜索其数据值为x的结点
    current=first->link;
    while(current!=first && current->data!=x)
    {
        current=current->link;
    }
    return current;

}
```

<img src="\images\article_images\image-20250922212126139.png" alt="image-20250922212126139" style="zoom: 43%;" />

<br>

## 4.插入算法

**同单链表插入算法**

<img src="\images\article_images\image-20251006114922996.png" alt="image-20251006114922996" style="zoom: 50%;" />

<br>

## 5.删除算法

**同单链表删除算法**

<img src="\images\article_images\image-20251006114935789.png" alt="image-20251006114935789" style="zoom: 50%;" />

<br>

<br>

<br>

# 四、双向循环链表

<img src="\images\article_images\image-20250922213435977.png" alt="image-20250922213435977" style="zoom: 50%;" />

<br>

<img src="\images\article_images\image-20250922213455906.png" alt="image-20250922213455906" style="zoom: 50%;" />

<br>

<img src="\images\article_images\image-20250922213514769.png" alt="image-20250922213514769" style="zoom: 50%;" />

<br>

## 1.模板定义的链表结点类

<img src="\images\article_images\image-20251006115537375.png" alt="image-20251006115537375" style="zoom:50%;" />

<br>

```cpp
template<class T>
struct DblNode  //链表结点类定义
{
    T data; //链表结点数据
    DblNode<T> *ILink,*rLink;   //前驱、后继指针
    DblNode(DblNode<T> *l=0,DblNode<T> *r=0)    //构造函数
    {
        ILink=l;
        rLink=r;
    }
    DblNode(T value,DblNode<T> *l=0,DblNode<T> *r=0)    //构造函数
    {
        data=value;
        ILink=l;
        rLink=r;
    }
};
```

<br>

## 2.模板定义的双向循环链表类

```cpp
template<class T>
class DblList   //双向循环链表类定义
{
private:
    DblNode<T> *first;  //表头指针

public:
    DblList(T uniqueVal)    //构造函数
    {
        first=new DblNode<T>(uniqueVal);
        first->rLink=first->lLink=first;
    }
    DblNode<T> *getFirst() const    //获取头结点
    {
        return first;
    }
    void setFirst(DblNode<T> *ptr)  //设置头结点地址
    {
        first=ptr;
    }
    DblNode<T> *Search(T x,int d);  //搜索算法：按d方向寻找值为x的结点
    DblNode<T> *Locate(int i,int d);    //定位算法：定位序号为i(>=0)的结点：d=0前驱方向，d!=0后继方向
    bool Insert(int i,T x,int d);   //插入算法：在第i个结点后插入包含值x的新结点
    bool Remove(int i,T &x,int d);  //删除算法：删除第i个结点
    bool IsEmpty()  //判断表空
    {
        return first->rLink==first;
    }
};
```

<br>

## 3.搜索算法

<img src="\images\article_images\image-20251006121943875.png" alt="image-20251006121943875" style="zoom:50%;" />

**`first` 哨兵节点**

```cpp
template<class T>
DblNode<T> *DblList<T>::Search(T x,int d)//搜索算法
{
    DblNode<T> *current=(d==0)? first->lLink : first->rLink;   //按d确定搜索方向
    while(current!=first && current->data!=x)
    {
        current=(d==0)? current->lLink : current->rLink;
    }
    if(current!=first)//first哨兵节点
    {
        return current;//搜索成功
    }
    else
    {
        return 0;   //搜索失败
    }
}
```

<br>

<br>

## 4.插入算法

<img src="\images\article_images\image-20251006122750436.png" alt="image-20251006122750436" style="zoom:50%;" />

<img src="\images\article_images\image-20251006122801803.png" alt="image-20251006122801803" style="zoom:50%;" />

<br>

```cpp
template<class T>
bool DblList<T>::Insert(int i,T x,int d)//插入算法
{
    DblNode<T> *current=Locate(i,d);//查找第i个结点
    if(current==0)
    {
        return false;//插入失败
    }
    DblNode<T> *newNd=new DblNode<T>(x);
    if(d==0)//前驱方向
    {
        newNd->lLink=current->lLink;//链入lLink链
        current->lLink=newNd;
        newNd->lLink->rLink=newNd;//链入rLink链
        newNd->rLink=current;
    }
    else//后继方向
    {
        newNd->rLink=current->rLink;
        current->rLink=newNd;
        newNd->rLink->lLink=newNd;
        newNd->lLink=current;
    }
    return true;    //插入成功
}
```

<br>

## 5.删除算法

<img src="\images\article_images\image-20251006124451985.png" alt="image-20251006124451985" style="zoom:50%;" />

<img src="\images\article_images\image-20251006124509324.png" alt="image-20251006124509324" style="zoom:50%;" />

```cpp
template<class T>
bool DblList<T>::Remove(int i,T &x,int d)//删除算法
{
    DblNode<T> *current=Locate(i,d);
    if(current==0)
    {
        return false;//删除失败
    }
    current->rLink->lLink=current->lLink;//从lLink摘下
    current->lLink->rLink=current->rLink;//从rLink摘下
    x=current->data;//保存删除的数据
    delete current;//删除
    return true;//删除成功
}
```

<br>

# 五、约瑟夫问题



<img src="\images\article_images\image-20251007120246398.png" alt="image-20251007120246398" style="zoom:50%;" />

<img src="\images\article_images\image-20251007152003448.png" alt="image-20251007152003448" style="zoom:50%;" />

<img src="\images\article_images\image-20251007152019141.png" alt="image-20251007152019141" style="zoom:50%;" />

<img src="\images\article_images\image-20251007152033370.png" alt="image-20251007152033370" style="zoom:50%;" />

<img src="\images\article_images\image-20251007152057506.png" alt="image-20251007152057506" style="zoom:50%;" />

<img src="\images\article_images\image-20251007152107428.png" alt="image-20251007152107428" style="zoom:50%;" />

```cpp
void Josephus(int n,int start,int m)//隔m人
{
    int counter,j,*A=new int[n];//counter出来的人数   n总人数
    for(j=0;j<n;++j)//初始化，把各位置号存入数组中
    {
        A[j]=j+1;
    }
    counter=1;
    start--;
    while(counter<n)//当前已站出人数比总人数少
    {
        cout <<A[start];//输出当前要站出来的人的位置号
        for(j=start;j<n-counter;++j)
        {
            A[j]=A[j+1];//位置号前移
        }
        start=(start+m-1)%(n-counter);
        counter++;
    }
    cout <<A[0];
}
```

<br>

<br>

# 六、递归成员函数

## 1.不带表头结点输出链表元素值

### 方法一

```cpp
class Link
{
    LinkNode *head;//不带表头结点

public:
    void Print(LinkNode *h);//递归函数
    LinkNode *getHead()
    {
        return head;
    }
};

void Link::Print(LinkNode *h)
{
    if(h!=0)//当前节点不为空
    {
        cout <<h->data <<" ";
        Print(h->link);//递归打印下一个节点
    }
}

void main()
{
    Link MyLink;
    //...
    MyLink.Print(MyLink.getHead());
}
```

<br>

### 方法二

```cpp
class link
{
    LinkNode *head;//不带表头结点
	void Print(LinkNode *h);//递归函数
    
public:
    void Print()//递归函数
    {
        Print(head);
    }
};
 
void Link::Print(LinkNode *h)
{
    if(h!=0)//当前节点不为空
    {
        cout <<h->data <<" ";
        Print(h->link);//递归打印下一个节点
    }
}

void main()
{
    Link MyLink;
    //...
    MyLink.Print();
}
```

<br>

## 2.带表头结点输出链表元素值

### 方法一

```cpp
class link
{
    LinkNode *first;//带表头结点
    
public:
    void Print(LinkNode *h);//递归函数
  	LinkNode *getFirstNext()
    {
        return first->next;
    }
};

void Link::Print(LinkNode *h)
{
    //方法一：正向输出
    if(h!=0)//当前节点不为空
    {
        cout <<h->data <<" ";
        Print(h->link);//递归打印下一个节点
    }
    /*	方法二：反向输出
    if(h!=0)//当前节点不为空
    {
    	Print(h->link);//递归打印下一个节点
        cout <<h->data <<" ";
    }
    */
}

void main()
{
	Link MyLink;
    //...
    MyLink.Print(MyLink.getFirstNext());
}
```

<br>

### 方法二

```cpp
class link
{
    LinkNode *first;//带表头结点
    void Print(LinkNode *h);//递归函数
    
public:
    void Print()
    {
        Print(first->next);
    }
};

void Link::Print(LinkNode *h)
{
    if(h!=0)//当前节点不为空
    {
        cout <<h->data <<" ";
        Print(h->link);//递归打印下一个节点
    }
}

void main()
{
	Link MyLink;
    //...
    MyLink.Print();
}
```

<br>

## 3.单链表表长

### 方法一

```cpp
int counter=0;

void Length1(LinkNode *h)
{
    if(h==0)//终止条件
    {
        return;
    }
    else
    {
        counter++;
        Length1(h->next);//递归项    
    }
}
```

<br>

### 方法二

```cpp
int counter=0;

void Length1(LinkNode *h)
{
    if(h==0)//终止条件
    {
        return;
    }
    else
    {
        Length1(h->next);//递归项
        counter++;    
    }
}
```

<br>

### 方法三

```cpp
int Length1(LinkNode *h)
{
    if(h==0)//终止条件
    {
        return;
    }
    else
    {
        return 1+Length1(h->next);//递归项  
    }
}
```
