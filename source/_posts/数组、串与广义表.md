---
title: 数组、串与广义表
date: 2026-02-26 23:53:46
tags:
- 数据结构
- 算法
- 串
- 稀疏矩阵
categories:
- 数据结构（C++）
description: 讲解数组存储、特殊矩阵压缩、稀疏矩阵转置、广义表结构及串的存储等数据结构核心内容
---



1. [数组](#一、数组)
    1.1 [一维数组（向量）](#1.一维数组（向量）)
    1.2 [二维数组（矩阵）](#2.二维数组（矩阵）)
    1.3 [三维数组](#3.三维数组)
2. [特殊矩阵](#二、特殊矩阵)
    2.1 [对称矩阵](#1.对称矩阵)
    2.2 [三角矩阵](#2.三角矩阵)
    2.3 [稀疏矩阵](#3.稀疏矩阵)
3. [广义表](#三、广义表)
    3.1 [存储方法1](#1.存储方法1)
    3.2 [存储方法2](#2.存储方法2)
4. [串](#四、串)
    4.1 [顺序存储结构](#1.顺序存储结构)
    4.2 [链式存储结构](#2.链式存储结构)

<br>

# 一、数组

## 1.一维数组（向量）

<img src="\images\article_images\image-20251217161304931.png" alt="image-20251217161304931" style="zoom: 50%;" />

**求一维数组中第i个元素的起始地址**

**`序号为i的元素起始地址=序号为1的元素起始地址 + (i-1) *每个元素所需的空间`**

<br>

## 2.二维数组（矩阵）

<img src="\images\article_images\image-20251217162431695.png" alt="image-20251217162431695" style="zoom:50%;" />

<br>

<img src="\images\article_images\image-20251217162510787.png" alt="image-20251217162510787" style="zoom:40%;" />

<br>

<img src="\images\article_images\image-20251217162535131.png" alt="image-20251217162535131" style="zoom:50%;" />

<img src="\images\article_images\image-20251217162618035.png" alt="image-20251217162618035" style="zoom:50%;" />

<br>

**求二维数组 `Amn` 中第 `i` 行 `j` 列元素的起始地址**

```cpp
LOC(A[i][j]) = LOC(A[0][0]) + i × n + j
```

**也是 `起始地址+前面的元素个数*每个元素所需空间`**

<br>

## 3.三维数组

<img src="\images\article_images\image-20251217162718820.png" alt="image-20251217162718820" style="zoom: 50%;" />

<br>

**三维数组元素 `A[i][j][k]` 的起始地址公式：**

```cpp
LOC(A[i][j][k]) = LOC(A[0][0][0]) + i × (d2 × d3) + j × d3 + k
```

<br>

# 二、特殊矩阵

## 1.对称矩阵

<img src="\images\article_images\image-20251226193536570.png" alt="image-20251226193536570" style="zoom: 50%;" />

<br>

## 2.三角矩阵

<img src="\images\article_images\image-20251226193647955.png" alt="image-20251226193647955" style="zoom:50%;" />

<br>

### 下三角存储（含主对角线）

**① 情况划分**

- 若 `i ≥ j`：元素直接存储
- 若 `i < j`：用 `A[j][i]` 代替

**② 地址计算公式**

第 `i` 行前面共有：

```cpp
1 + 2 + … + (i − 1) = (i − 1)i / 2
```

因此：

```cpp
LOC(A[i][j]) = LOC(A)
             + (i − 1)i / 2
             + (j − 1)
```

<br>

### 上三角存储（含主对角线）

**① 情况划分**

- 若 `i ≤ j`：元素直接存储
- 若 `i > j`：用 `A[j][i]` 代替

**② 地址计算公式**

前面完整行的元素个数为：

```cpp
n + (n − 1) + … + (n − i + 2)
= (i − 1)(2n − i + 2) / 2
```

因此：

```cpp
LOC(A[i][j]) = LOC(A)
             + (i − 1)(2n − i + 2) / 2
             + (j − i)
```

<br>

<br>

## 3.稀疏矩阵

### 顺序存储类定义

```cpp
//稀疏矩阵顺序存储类定义
struct RCV
{
    int row,col;//row行号  col列号
    float value;//矩阵中非零元素的值
};

class SMatrix
{
private:
    RCV *item;//指向RCV类型数组的指针，用于存储稀疏矩阵的所有非零元素
    int r,c,num;//r矩阵总行数   c矩阵总列数     num矩阵中非零元素个数

public:
    SMatrix()
    {
        item=NULL;
        r=0;
        c=0;
        num=0;
    }
    SMatrix(RCV a[],int n,int row,int col);//a[]是一个三元组
    SMatrix tran();//普通转置算法
    SMatrix tran1();//改进后的转置算法
    SMatrix plus(SMatrix &b);
    SMatrix mult(SMatrix &b);
    void prnt();
};
```

<br>

### 构造函数

```cpp
//设置三元组表a、长度n及行数row、列数col四个参数
//创建的三元组表由参数a、n确定，而行数、列数分别由参数row、col确定。
//功能：按指定的参数分配存储空间并设置数据成员的初值。
SMatrix::SMatrix(RCV a[],int n,int row,int col)//构造函数
{
    r=row;
    c=col;
    num=n;
    item=new RCV[num];
    for(int i=0;i<num;++i)
    {
        item[i]=a[i];
    }
}
```

<br>

<br>

### 稀疏矩阵的转置算法

**稀疏矩阵转置的本质**

**1️⃣ 数学上的转置**

普通矩阵转置规则：

```cpp
A[i][j] → Aᵀ[j][i]
```

**2️⃣ 稀疏矩阵怎么转置？**

由于我们只存非零元素：

> **每个三元组的 row 和 col 交换即可**

```cpp
(row, col, value)
→
(col, row, value)
```

<img src="\images\article_images\image-20251227000350891.png" alt="image-20251227000350891" style="zoom:50%;" />

⚠️ **数学上已经是转置了，但不规范**

<br>

**稀疏矩阵的默认约定通常要求：**

> **按 `row` 升序排列**
> **`row` 相同 → 按 `col` 升序**

这样：

- 方便输出
- 方便查找
- 方便后续运算（加法、乘法）

<img src="\images\article_images\image-20251227000422431.png" alt="image-20251227000422431" style="zoom:50%;" />

<br>

#### 普通转置算法

```cpp
//稀疏矩阵的转置操作
/*
功能:返回当前矩阵对象的转置矩阵，按以下过程处理：
(1)创建一个稀疏矩阵×，形成x的r,C,num，并按指定的长度分配存储空间。
(2)按当前矩阵的列(即×的行)进行循环处理：对当前矩阵的每一列扫描一次三元组，
找出相应的元素，交换其行号与列号并添加到转置矩阵×的三元组表中。
(3)返回结果矩阵x。
*/
SMatrix SMatrix::tran()
{
    SMatrix x;
    int k;
    x.r=c;
    x.c=r;
    x.num=num;
    x.item=new RCV[num];
    if(num>0)//判断是否存在非零元素
    {
        k=0;//转置矩阵元素计数器
        for(int i=0;i<c;++i)//遍历原矩阵列号
        {
            for(int j=0;j<num;++j)//遍历原矩阵非零元素
            {
                if(item[j].col==i)//如果当前非零元素的列号等于当前列i
                {
                    x.item[k].row=item[j].col;
                    x.item[k].col=item[j].row;
                    x.item[k].value=item[j].value;
                    k++;
                }
            }
        }
    }
    return x;
}
```

**时间复杂度大**

<br>

#### 快速转置算法（改进）

```cpp
//稀疏矩阵快速转置
/*
功能：使用快速转置法计算并返回当前矩阵的转置矩阵，其处理过程为：
(1)创建一个稀疏矩阵x， 形成x的r, C, num， 并按指定的长度分配存储空间。
(2)求当前矩阵中各列非零元的个数，将结果存入数组rnum。
(3)求结果矩阵中各行起始位置，将结果存入数组rstart。
(4)依次扫描当前矩阵中的三元组表，对每一个三元组行列置换后
按原列号col存入x中由rstart[col]指示的位置，并使其位置加1。
(5)返回结果矩阵x。
*/
SMatrix SMatrix::tran1()
{
    SMatrix x;
    //int rnum[100],rstart[100]; 修改为下面的*rnum, *rstart
    x.r=c;
    x.c=r;
    x.num=num;
    x.item=new RCV[num];
    
    if(num==0)
    {
        return x;
    }
    //rnum统计「原始稀疏矩阵」中每一列有多少个非零元素（比如原始矩阵第0列有2个非零元素，rnum[0]就等于2）
    //rstart记录「转置矩阵」中每一行的第一个非零元素，在x.item数组（存转置后非零元素）中的起始下标
    //（比如转置矩阵第0行第一个元素在x.item[0]，第2行第一个元素在x.item[2]）
    int *rnum=new int[c];
    int *rstart=new int[c];
    for(int i=0;i<c;++i)
    {
        rnum[i]=0;
    }
    for(int i=0;i<num;++i)//当前矩阵各列的非零元素的个数存入rnum
    {
        rnum[item[i].col]++;//对应列的计数加1
    }
    rstart[0]=0;//转置矩阵第0行的第一个非零元素，在x.item数组中的起始下标是0（也就是第一个元素就存在x.item[0]）
    for(int i=1;i<c;++i)
    {
        rstart[i]=rnum[i-1]+rstart[i-1];    
    }
    for(int i=0;i<num;++i)
    {
        int j=item[i].col;//确定当前原始元素，在转置矩阵中对应的行号
        x.item[rstart[j]].row=j;//转置元素的行号=原始元素的列号（j）
        x.item[rstart[j]].col=item[i].row;//转置元素的列号=原始元素的行号
        x.item[rstart[j]].value=item[i].value;
        rstart[j]++;
    }
    delete []rnum;
    delete []rstart;
    return x;
}
```

<br>

#### 十字链表转置（计算量最小）

```cpp
struct OLNode//非零结点结构
{
    int row;
    int col;
    int value;
    OLNode *right;// 指向同行下一个非零元
    OLNode *down;// 指向同列下一个非零元
};
struct CrossMatrix
{
    int r;
    int c;
    int num;
    //rhead[i]：第i行的第一个非零结点 	  chead[j]：第j列的第一个非零结点
    OLNode **rhead;// 行头指针数组
    OLNode **chead;// 列头指针数组
    CrossMatrix();
    CrossMatrix(int row, int col);
    ~CrossMatrix();
};

CrossMatrix::CrossMatrix()//构造函数
{
    r = 0;
    c = 0;
    num = 0;
    rhead = nullptr;
    chead = nullptr;
}

CrossMatrix::CrossMatrix(int row, int col)//构造函数
{
    r = row;
    c = col;
    num = 0;
    rhead = new OLNode*[r];
    chead = new OLNode*[c];
    for(int i = 0; i < r; ++i) 
    {	
        rhead[i] = nullptr;
    }
    for(int j = 0; j < c; ++j) 
    {
        chead[j] = nullptr;
    }
}

CrossMatrix::~CrossMatrix()//析构函数
{
    if(rhead == nullptr || chead == nullptr) 
    {
		return;
    }
    for(int i = 0; i < r; ++i)
    {
        OLNode *p = rhead[i];
        while(p)
        {
            OLNode *q = p->right;
            delete p;
            p = q;
        }
    }
    delete [] rhead;
    delete [] chead;
}


CrossMatrix CrossMatrix::tran()//转置算法
{
    CrossMatrix x;
    x.r=c;
    x.c=r;
    x.num=num;
    x.rhead=chead;
    x.chead=rhead;
    return x;
}
```

<br>

<br>

### 链式存储

#### 带行指针的链式存储结构

不做介绍

<br>

#### 带列指针的链式存储结构

不做介绍

<br>

#### 十字链表

<img src="\images\article_images\image-20251227201351226.png" alt="image-20251227201351226" style="zoom:50%;" />

<br>

<img src="\images\article_images\image-20251227183043771.png" alt="image-20251227183043771" style="zoom: 33%;" />

<br>

<br>

<br>

# 三、广义表

<img src="\images\article_images\image-20251227183144028.png" alt="image-20251227183144028" style="zoom:50%;" />

<br>

**长度（Length）： 最外层括号里，直接包含的元素个数**

- 只数**第一层**
- 不往里拆

<br>

**深度（Depth）：括号嵌套的最大层数**

- 原子深度 = 0
- 空表深度 = 1
- 非空表深度 = 1 + 各元素深度最大值

注意：（a,b) 表的深度是1，注意区分表的深度和元素的深度

<br>

**表头（Head）： 最外层的第一个元素**

- 可以是原子
- 也可以是子表

<br>

**表尾（Tail）：删掉表头后，剩下的“表”**

注意：表尾一定还是一个表（可能是空表）

<br>

<img src="\images\article_images\image-20251227183158205.png" alt="image-20251227183158205" style="zoom: 50%;" />

<img src="\images\article_images\image-20251227184559545.png" alt="image-20251227184559545" style="zoom:50%;" />

<img src="\images\article_images\image-20251227184636404.png" alt="image-20251227184636404" style="zoom:50%;" />

<br>

## 1.存储方法1

<br>

<img src="\images\article_images\image-20251227185209621.png" alt="image-20251227185209621" style="zoom: 45%;" />

```cpp
class GenList;//广义表
class GenListNode//广义表结点
{
    friend class GenList;//友元类，GenList可以直接访问GenListNode的私有成员

private:
    bool tag;//False表示原子元素，True表示表元素
    //union数据类型：所有成员共享同一块连续的内存空间，同一时间只能有一个成员有效，共用体的大小等于其最大成员的大小
    union
    {
        char data;//当tag=false（原子节点）时，该成员有效
        GenListNode *head;//当tag=true（表节点）时，该成员有效
    };
    GenListNode *tail;//存储当前节点的表尾指针
};
class GenList
{
public:
    //各种广义表的操作

private:
    GenListNode *first;
};
```

<br>

<br>

## 2.存储方法2

```cpp
class GenList;//广义表
class GenListNode//广义表结点类
{
    friend class GenList;

private:
    bool tag;//False表示原子元素，True表示表元素
    union
    {
        char data;
        struct
        {
            GenListNode *head;
            GenListNode *tail;
        };
    };
};
class GenList
{
public:
    //各种广义表的操作

private:
    GenListNode *first;
};
```

<br>

<br>

# 四、串

<br>

<img src="\images\article_images\image-20251228090501199.png" alt="image-20251228090501199" style="zoom:50%;" />

<img src="\images\article_images\image-20251228090535937.png" alt="image-20251228090535937" style="zoom:50%;" />

<img src="\images\article_images\image-20251228090556480.png" alt="image-20251228090556480" style="zoom:50%;" />

<br>

## 1.顺序存储结构

```cpp
//顺序存储结构类型定义
const int maxlen=100;//允许的串最大长度;
struct Tstr
{
    int curlen;
    char str[maxlen];
};
```

<br>

## 2.链式存储结构

<img src="\images\article_images\image-20251228091138359.png" alt="image-20251228091138359" style="zoom:67%;" />

```cpp
struct LNode
{
    char data;
    LNode *next;
};

struct LStr
{
    LNode *head;
    int len;
};
```

