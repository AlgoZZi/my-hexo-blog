---
title: Python程序设计习题——类与继承
date: 2026-01-18 00:17:16
tags:
- Python
categories:
- Python语言程序设计
description: " "
---

# 类与继承

# 选择题

## 1. 题目

```python
定义类如下
class Hello():
    def __init__(self,name)
        self.name=name
    def showInfo(self)
        print(self.name)
下面代码能正常执行的 (   )

A.
h = Hello()
h.showInfo(‘张三’)
B.
h = Hello(‘张三’)
h.showInfo()
C.
h = Hello
h.showInfo()
D.
h = Hello(‘admin’)
showInfo
```

**答案：B**

**选项A**：错误，\_\_init__方法需要name参数，但创建对象时没有传入，且showInfo方法不需要参数却传入了'张三'。

**选项B**：正确，创建对象时传入了name参数，showInfo方法正确调用，不需要额外参数。

**选项C**：错误，h=Hello没有创建实例，直接赋值了类对象，无法调用实例方法showInfo。

**选项D**：错误，showInfo是方法，需要通过对象调用，直接写showInfo不会执行任何操作。

<br>

## 2. 题目

```python
定义类如下：
class A():
    def a():
        print(“a”)
class B ():
    def b():
        print(“b”)
class C():
    def c():
        print(c)
class D(A,C):
    def d():
        print(“d”)
d = D()
d.a()
d.b()
d.d()
则程序执行的结果是（  ）

A.a,b,d
B.执行会报错
C.a,d
D.d,a
```

**答案：B**

**选项A**：错误，d.b()无此方法，d.a()和d.d()因缺少self参数报错，无法输出该结果。

**选项B**：正确，程序存在多重致命错误：a()和d()方法缺少self参数，d.b()调用了不存在的方法，必然触发异常。

**选项C**：错误，d.a()和d.d()均会因缺少self参数报错，无法正常打印。

**选项D**：错误，方法调用均触发报错，无正常输出。

<br>

## 3. 题目

```python
关于python类 说法错误的是（  ）

A.类的静态属性可以用类名和对象来调用
B.类的实例方法在创建对象前可以调用
C.类的实例方法必须创建对象后才可以调用
D.类的类方法可以用对象和类名来调用
```

**答案：B**

**选项A**：正确，类的静态属性可以通过类名和对象名访问。

**选项B**：错误，实例方法必须通过对象调用，创建对象前无法调用。

**选项C**：正确，实例方法必须通过对象调用。

**选项D**：正确，类方法可以通过类名和对象名访问。

<br>

## 4. 题目

```python
(多选)
定义类如下：
   class  Hello():
            pass
下面说明错误的是（    ）

A.该类实例中只包含__dir__（），不包含__hash__（）
B.该类实例中包含__hash__（）方法
C.该类没有定义任何方法，所以该实例中没有包含任何方法
D.该类实例中包含__dir__（）方法
```

**答案：AC**

**选项A**：错误，类实例会继承object类的所有特殊方法，包括\__hash__()。

**选项B**：正确，类实例继承了object类的\__hash__()方法。

**选项C**：错误，即使类没有定义任何方法，实例也会继承object类的方法。

**选项D**：正确，类实例继承了object类的\__dir__()方法。

<br>

# 判断题

## 1. 题目

```python
定义类时所有实例方法的第一个参数用来表示对象本身，在类的外部通过对象名来调用实例方法时不需要为该参数传值。  (  )
```

**答案：对**

**解析**：在Python中，实例方法的第一个参数通常命名为self，表示对象本身，在调用时Python会自动将对象传递给这个参数，不需要显式传值。

<br>

## 2. 题目

```python
只可以动态为对象增加数据成员，而不能为对象动态增加成员方法。   (   )
```

**答案：错**

**解析**：在Python中，既可以动态为对象增加数据成员，也可以动态为对象增加成员方法，可以通过赋值的方式实现。

<br>

## 3. 题目

```python
对于Python类中的私有成员，可以通过“对象名._类名__私有成员名”的方式来访问。 (   )
```

**答案：对**

**解析**：Python中的私有成员使用双下划线前缀（\_\_）定义，但实际上只是进行了名称修饰，仍然可以通过“对象名._类名__私有成员名”的方式访问。

<br>

## 4. 题目

```python
如果定义类时没有编写析构函数，Python将提供一个默认的析构函数进行必要的资源清理工作。(    ) 
```

**答案：对**

**解析**：如果定义类时没有编写析构函数，Python会提供一个默认的析构函数，用于释放对象占用的资源。

<br>

## 5. 题目

```python
Python支持多继承，如果父类中有相同的方法名，而在子类中调用时没有指定父类名，则Python解释器将从左向右按顺序进行搜索。  (   )
```

**答案：对**

**解析**：Python支持多继承，当调用方法时，解释器会按照MRO（方法解析顺序）从左向右搜索父类中的方法。

<br>

## 6. 题目

```python
Python中没有严格意义上的私有成员。 (   )
```

**答案：对**

**解析**：Python中的私有成员只是通过名称修饰（name mangling）来实现的，并不是真正的私有，可以通过特殊方式访问，因此没有严格意义上的私有成员。

<br>

## 7. 题目

```python
在类定义的外部没有任何办法可以访问对象的私有成员。(   )
```

**答案：错**

**解析**：虽然Python使用名称修饰来保护私有成员，但仍然可以通过“对象名._类名__私有成员名”的方式在外部访问。

<br>

## 8. 题目

```python
定义类时所有实例方法的第一个参数用来表示对象本身,在类的外部通过对象名来调用实例方法时不需要为该参数传值.  (  )
```

**答案：对**

**解析**：实例方法的第一个参数表示对象本身，调用时不需要显式传值。

<br>

## 9. 题目

```python
Python中一切内容都可以称为对象。  (   )
```

**答案：对**

**解析**：在Python中，一切都是对象，包括数字、字符串、函数、类等。

<br>

## 10. 题目

```python
定义类时，在一个方法前面使用@staticmethod进行修饰，则该方法属于静态方法。(    )
```

**答案：对**

**解析**：@staticmethod装饰器用于定义静态方法，静态方法不需要self或cls参数，可以通过类名或对象名调用。

<br>

## 11. 题目

```python
在设计派生类时，基类的私有成员默认是不会继承的。(   )
```

**答案：对**

**解析**：在Python中，基类的私有成员（使用双下划线前缀定义的成员）默认不会被派生类继承，这是名称修饰的结果。

<br>

# 填空题

## 1. 题目

```python
在Python中，不论类的名字是什么，构造方法的名字都是______
```

**答案：\_\_init\_\_**

**解析**：在Python中，构造方法的固定名称是__\_\_init\_\___，用于初始化对象。

<br>

## 2. 题目

```python
在Python中定义类时，与特殊方法名__floordiv__()对应的运算符为__________
```

**答案：//**

**解析**：在Python中，\_\_floordiv\_\_()方法对应于整数除法运算符//。

<br>

## 3. 题目

```python
定义类时，在一个方法前面使用装饰器_________进行修饰，则该方法属于类方法。
```

**答案：@classmethod**

**解析**：@classmethod装饰器用于定义类方法，类方法的第一个参数通常是cls，表示类本身。

<br>

## 4. 题目

```python
在Python定义类时，与运算符“**”对应的特殊方法名为_____
```

**答案：\__pow__()**

**解析**：在Python中，\__pow__()方法对应于幂运算符**。

<br>

## 5. 题目

```python
通过装饰器________可以将类中的方法当作属性成员进行访问。
```

**答案：@property**

**解析**：@property装饰器用于将方法转换为属性，可以通过属性访问的方式调用方法，而不需要加括号。
